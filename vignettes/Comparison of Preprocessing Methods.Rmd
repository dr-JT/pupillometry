---
title: "Comparison of Preprocessing Methods"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

One question you may have is, what parameters should I specify for each preprocessing method? This can be hard to determine but it helps to have a visual aid.

## `plot.comparison()`

With `plot.comparison()` you can visually compare how different preprocessing parameters change the shape of the pupil data.

To use `plot.comparison()` you first need to create the preprocessed data files with different parameters (from a single raw data file) with `preprocess()`. You may need to rename the file after running each `preprocess()` so that it doesn't get overwritten. 

Parameters:

* __import__: The directory where the "test" comparison files are located

* __files__:  A vector `c()` of the filenames to be compared

* __labels__:  A vector `c()` of labels to use in the figure legend for each data file

* __trial__: Which trial to select from the data file

* __title__: Option to give the figure a title

* __legend.title__: Option to give the legend a title

********

********

## Usage

There might be many comparisons you would like to make. For visual purposes it probably is best to not display more than three time-series on a graph at one time. You should also include a time-series in which no preprocessing has been performed, that is the `naremoved` file.

Some comparisons you might want to make are different smoothing window sizes `smooth.window`, or different maxgap sizes `interpolate.maxgap`.

To make the first plot displayed below:

```r
plot.comparison(import = "data/test", 
                files = c("Pitch_Discrimination_19_PupilData_interpolated_cubic-spline.txt",
                          "Pitch_Discrimination_19_PupilData_interpolated_linear.txt",
                          "Pitch_Discrimination_19_PupilData_naremoved.txt"),
                labels = c("cubic-spline",
                           "linear",
                           "No Preprocessing"), 
                trial = 6,
                title = paste("Trial", 6, sep = " "),
                legend.title = "interpolation.type")
```


## method.first

Here are some examples from `plot.comparison()` that demonstrate important differences when choosing whether to interpolate or smooth the data first.

From these examples, it can be seen that if you are gonig to apply a `cubic-spline` interpolation, then you should apply smoothing `smooth = TRUE` and it is important that you choose `method.first = "smooth"`. Otherwise the data get overly distorted if you apply interpolation first (see Trial 6).

These data come from a pitch discrimination task as described in the [Example Data Set](https://dr-jt.github.io/pupillometry/articles/Example%20Data%20Set.html) article. Time = 0 is the onset of the first tone.

********

In all the figures, at some point the time-series "lines" might overlap considerably and it only looks like one color is there. In fact, all colored lines are present during those periods, they are just overlapping. If smoothing was applied, then `smooth.window = 500`.

On Trial 6 there are a couple of "major" gaps of missing pupil data. You can see that if you use `cubic-spline` interpolation without smoothing (*Figure 1*), then the interpolated values are exaggerated and most likely unrealistic (see the period of 0 - 500 ms). It is very unlikely that pupil size is decreasing and then increasing by over 1 mm within a 500 ms interval. Thee `cubic-spline` interpolation might be modeling too much high frequency noise in the data. You can see that the `linear` interpolation does not suffer from the same problem. However, if there was truly a decrease during that interval then the `linear` interpolation is not capturing that.

<img src="../reference/figures/Trial6-interpolation.type.png" align = "center" />

*Figure 1*

********

*Figure 2* shows the same trial but with smoothing applied. With either `method.first = "smooth"` (**green line**) or `method.first = "interpolate"` (**pink line**). Both lines used **cubic-spline interpolation**, the only difference is whether smoothing was applied first or not. You can see that applying smoothing before a cubice-spline interpolation avoids the issue seen in *Figure 1* and the pink line in *Figure 2*.

<img src="../reference/figures/Trial6--cubic-spline-hann.png" align = "center" />

<br><br>

********

There is not as big of a difference for `linear` interpolation. 

For `linear` interpolation, the issue of applying smoothing first or not is not as big of an issue (*Figure 3*).

<img src="../reference/figures/Trial6--linear-hann.png" align = "center" />

<br><br>

********

And here is Trial 6 if you were to do smoothing but no interpolation (*Figure 4*)

<img src="../reference/figures/Trial6-smooth.type.png" align = "center" />

<br><br>

********

Trial 2 shows a similar pattern when you use cubic-spline interpolation (*Figure 5*).

<img src="../reference/figures/Trial2--cubic-spline-hann.png" align = "center" />

********

These comparisons demonstrate the importance of being careful what types of preprocessing paramteres you specify. Based on this small sample of data it is suggested, that if you are going to apply an interpolation method, that you first apply smoothing.







